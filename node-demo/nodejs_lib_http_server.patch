diff --git a/lib/_http_server.js b/lib/_http_server.js
index 3fd14faedf..1dceb4e7c4 100644
--- a/lib/_http_server.js
+++ b/lib/_http_server.js
@@ -560,9 +560,13 @@ function setupConnectionsTracking() {
     setInterval(checkConnections.bind(this), this.connectionsCheckingInterval).unref();
 }
 
-function httpServerPreClose(server) {
-  server.closeIdleConnections();
-  clearInterval(server[kConnectionsCheckingInterval]);
+function httpServerPreClose(server, callback) {
+  server.closeIdleConnections(() => {
+    clearInterval(server[kConnectionsCheckingInterval]);
+    if (typeof callback === 'function') {
+      callback();
+    }
+  });
 }
 
 function Server(options, requestListener) {
@@ -592,8 +596,27 @@ function Server(options, requestListener) {
       keepAliveInitialDelay: options.keepAliveInitialDelay,
       highWaterMark: options.highWaterMark });
 
+  this.drainStarted = false;
+  this.drainTimeout = options.drainTimeout || 0;
+  this.drainConnectionsPollInterval = options.drainConnectionsPollInterval || 500;
+
   if (requestListener) {
-    this.on('request', requestListener);
+    // Do we want to gracefully drain existing keep-alive connections
+    // using 'Connection: close' once server.close() was called?
+    if (this.drainTimeout > 0) {
+      // Yes, we do, so wrap the requestListener using a listener
+      // that sets the 'Connection: close' header.
+      const gracefulHandler = (req, res) => {
+        if (this.drainStarted) {
+          res.setHeader('Connection', 'close');
+        }
+        return requestListener.bind(this)(req, res);
+      };
+      this.on('request', gracefulHandler);
+    } else {
+      // Default behaviour: No graceful listener.
+      this.on('request', requestListener);
+    }
   }
 
   // Similar option to this. Too lazy to write my own docs.
@@ -614,8 +637,9 @@ ObjectSetPrototypeOf(Server.prototype, net.Server.prototype);
 ObjectSetPrototypeOf(Server, net.Server);
 
 Server.prototype.close = function close() {
-  httpServerPreClose(this);
-  ReflectApply(net.Server.prototype.close, this, arguments);
+  httpServerPreClose(this, () => {
+    ReflectApply(net.Server.prototype.close, this, arguments);
+  })
   return this;
 };
 
@@ -635,19 +659,46 @@ Server.prototype.closeAllConnections = function closeAllConnections() {
   }
 };
 
-Server.prototype.closeIdleConnections = function closeIdleConnections() {
+Server.prototype.closeIdleConnections = function closeIdleConnections(callback) {
   if (!this[kConnections]) {
     return;
   }
 
-  const connections = this[kConnections].idle();
+  const fn = () => {
+    // Destroy all still remaining idle connections.
+    const connections = this[kConnections].idle();
+    for (let i = 0, l = connections.length; i < l; i++) {
+      if (connections[i].socket._httpMessage && !connections[i].socket._httpMessage.finished) {
+        continue;
+      }
+      connections[i].socket.destroy();
+    }
+    if (typeof callback === 'function') {
+      callback();
+    }
+  }
 
-  for (let i = 0, l = connections.length; i < l; i++) {
-    if (connections[i].socket._httpMessage && !connections[i].socket._httpMessage.finished) {
-      continue;
+  // For graceful draining, if drainTimeout > 0 (see below)
+  let startTime = Date.now()
+  let timer = null;
+  const checkFn = () => {
+    const connections = this[kConnections].all();
+    if (Date.now() - startTime > this.drainTimeout || connections.length === 0) {
+      // Either drain period has ended, or we have no open connections anymore.
+      // We can close now.
+      clearInterval(timer);
+      timer = null;
+      fn();
     }
+  };
 
-    connections[i].socket.destroy();
+  if (this.drainTimeout > 0 && !this.drainStarted) {
+    this.drainStarted = true;
+    // Start polling for idle connections.
+    // If all connections are gone or drain period ends, we call the callback.
+    timer = setInterval(checkFn, this.drainConnectionsPollInterval);
+  } else {
+    fn();
   }
 };
 
@@ -1390,3 +1441,4 @@ module.exports = {
   httpServerPreClose,
   kConnectionsCheckingInterval,
 };
+
